// ------ Tessarray ------
// Copyright 2016 Dixon and Moe
// Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.

// ------ Flickr Justified Layout ------
require=function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(require,module,exports){/*!
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.
 * @license
 */
var merge=require("merge");var Row=module.exports=function(params){this.top=params.top;this.left=params.left;this.width=params.width;this.spacing=params.spacing;this.targetRowHeight=params.targetRowHeight;this.targetRowHeightTolerance=params.targetRowHeightTolerance;this.minAspectRatio=this.width/params.targetRowHeight*(1-params.targetRowHeightTolerance);this.maxAspectRatio=this.width/params.targetRowHeight*(1+params.targetRowHeightTolerance);this.edgeCaseMinRowHeight=params.edgeCaseMinRowHeight;this.edgeCaseMaxRowHeight=params.edgeCaseMaxRowHeight;this.widowLayoutStyle=params.widowLayoutStyle;this.isBreakoutRow=params.isBreakoutRow;this.items=[];this.height=0};Row.prototype={addItem:function(itemData){var newItems=this.items.concat(itemData),rowWidthWithoutSpacing=this.width-(newItems.length-1)*this.spacing,newAspectRatio=newItems.reduce(function(sum,item){return sum+item.aspectRatio},0),targetAspectRatio=rowWidthWithoutSpacing/this.targetRowHeight,previousRowWidthWithoutSpacing,previousAspectRatio,previousTargetAspectRatio;if(this.isBreakoutRow){if(this.items.length===0){if(itemData.aspectRatio>=1){this.items.push(itemData);this.completeLayout(rowWidthWithoutSpacing/itemData.aspectRatio,this.widowLayoutStyle);return true}}}if(newAspectRatio<this.minAspectRatio){this.items.push(merge(itemData));return true}else if(newAspectRatio>this.maxAspectRatio){if(this.items.length===0){this.items.push(merge(itemData));this.completeLayout(rowWidthWithoutSpacing/newAspectRatio,this.widowLayoutStyle);return true}previousRowWidthWithoutSpacing=this.width-(this.items.length-1)*this.spacing;previousAspectRatio=this.items.reduce(function(sum,item){return sum+item.aspectRatio},0);previousTargetAspectRatio=previousRowWidthWithoutSpacing/this.targetRowHeight;if(Math.abs(newAspectRatio-targetAspectRatio)>Math.abs(previousAspectRatio-previousTargetAspectRatio)){this.completeLayout(previousRowWidthWithoutSpacing/previousAspectRatio,this.widowLayoutStyle);return false}else{this.items.push(merge(itemData));this.completeLayout(rowWidthWithoutSpacing/newAspectRatio,this.widowLayoutStyle);return true}}else{this.items.push(merge(itemData));this.completeLayout(rowWidthWithoutSpacing/newAspectRatio,this.widowLayoutStyle);return true}},isLayoutComplete:function(){return this.height>0},completeLayout:function(newHeight,widowLayoutStyle){var itemWidthSum=this.left,rowWidthWithoutSpacing=this.width-(this.items.length-1)*this.spacing,clampedToNativeRatio,roundedHeight,clampedHeight,errorWidthPerItem,roundedCumulativeErrors,singleItemGeometry,centerOffset;if(typeof widowLayoutStyle==="undefined"||["justify","center","left"].indexOf(widowLayoutStyle)<0){widowLayoutStyle="left"}roundedHeight=Math.round(newHeight);clampedHeight=Math.max(this.edgeCaseMinRowHeight,Math.min(roundedHeight,this.edgeCaseMaxRowHeight));if(roundedHeight!==clampedHeight){this.height=clampedHeight;clampedToNativeRatio=rowWidthWithoutSpacing/clampedHeight/(rowWidthWithoutSpacing/roundedHeight)}else{this.height=roundedHeight;clampedToNativeRatio=1}this.items.forEach(function(item){item.top=this.top;item.width=Math.round(item.aspectRatio*this.height*clampedToNativeRatio);item.height=this.height;item.left=itemWidthSum;itemWidthSum+=item.width+this.spacing},this);if(widowLayoutStyle==="justify"){itemWidthSum-=this.spacing+this.left;errorWidthPerItem=(itemWidthSum-this.width)/this.items.length;roundedCumulativeErrors=this.items.map(function(item,i){return Math.round((i+1)*errorWidthPerItem)});if(this.items.length===1){singleItemGeometry=this.items[0];singleItemGeometry.width-=Math.round(errorWidthPerItem)}else{this.items.forEach(function(item,i){if(i>0){item.left-=roundedCumulativeErrors[i-1];item.width-=roundedCumulativeErrors[i]-roundedCumulativeErrors[i-1]}else{item.width-=roundedCumulativeErrors[i]}})}}else if(widowLayoutStyle==="center"){centerOffset=(this.width-itemWidthSum)/2;this.items.forEach(function(item){item.left+=centerOffset+this.spacing},this)}},forceComplete:function(fitToWidth,rowHeight){if(typeof rowHeight==="number"){this.completeLayout(rowHeight,this.widowLayoutStyle)}else{this.completeLayout(this.targetRowHeight,this.widowLayoutStyle)}},getItems:function(){return this.items}}},{merge:2}],2:[function(require,module,exports){(function(isNode){var Public=function(clone){return merge(clone===true,false,arguments)},publicName="merge";Public.recursive=function(clone){return merge(clone===true,true,arguments)};Public.clone=function(input){var output=input,type=typeOf(input),index,size;if(type==="array"){output=[];size=input.length;for(index=0;index<size;++index)output[index]=Public.clone(input[index])}else if(type==="object"){output={};for(index in input)output[index]=Public.clone(input[index])}return output};function merge_recursive(base,extend){if(typeOf(base)!=="object")return extend;for(var key in extend){if(typeOf(base[key])==="object"&&typeOf(extend[key])==="object"){base[key]=merge_recursive(base[key],extend[key])}else{base[key]=extend[key]}}return base}function merge(clone,recursive,argv){var result=argv[0],size=argv.length;if(clone||typeOf(result)!=="object")result={};for(var index=0;index<size;++index){var item=argv[index],type=typeOf(item);if(type!=="object")continue;for(var key in item){var sitem=clone?Public.clone(item[key]):item[key];if(recursive){result[key]=merge_recursive(result[key],sitem)}else{result[key]=sitem}}}return result}function typeOf(input){return{}.toString.call(input).slice(8,-1).toLowerCase()}if(isNode){module.exports=Public}else{window[publicName]=Public}})(typeof module==="object"&&module&&typeof module.exports==="object"&&module.exports)},{}],"justified-layout":[function(require,module,exports){/*!
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.
 * @license
 */
"use strict";var merge=require("merge"),Row=require("./row"),layoutConfig={},layoutData={};function createNewRow(){var isBreakoutRow;if(layoutConfig.fullWidthBreakoutRowCadence!==false){if((layoutData._rows.length+1)%layoutConfig.fullWidthBreakoutRowCadence===0){isBreakoutRow=true}}return new Row({top:layoutData._containerHeight,left:layoutConfig.containerPadding.left,width:layoutConfig.containerWidth-layoutConfig.containerPadding.left-layoutConfig.containerPadding.right,spacing:layoutConfig.boxSpacing.horizontal,targetRowHeight:layoutConfig.targetRowHeight,targetRowHeightTolerance:layoutConfig.targetRowHeightTolerance,edgeCaseMinRowHeight:.5*layoutConfig.targetRowHeight,edgeCaseMaxRowHeight:2*layoutConfig.targetRowHeight,rightToLeft:false,isBreakoutRow:isBreakoutRow,widowLayoutStyle:layoutConfig.widowLayoutStyle})}function addRow(row){layoutData._rows.push(row);layoutData._layoutItems=layoutData._layoutItems.concat(row.getItems());layoutData._containerHeight+=row.height+layoutConfig.boxSpacing.vertical;return row.items}function computeLayout(itemLayoutData){var laidOutItems=[],itemAdded,currentRow,nextToLastRowHeight;if(layoutConfig.forceAspectRatio){itemLayoutData.forEach(function(itemData){itemData.forcedAspectRatio=true;itemData.aspectRatio=layoutConfig.forceAspectRatio})}itemLayoutData.some(function(itemData,i){if(isNaN(itemData.aspectRatio)){throw new Error("Item "+i+" has an invalid aspect ratio")}if(!currentRow){currentRow=createNewRow()}itemAdded=currentRow.addItem(itemData);if(currentRow.isLayoutComplete()){laidOutItems=laidOutItems.concat(addRow(currentRow));if(layoutData._rows.length>=layoutConfig.maxNumRows){currentRow=null;return true}currentRow=createNewRow();if(!itemAdded){itemAdded=currentRow.addItem(itemData);if(currentRow.isLayoutComplete()){laidOutItems=laidOutItems.concat(addRow(currentRow));if(layoutData._rows.length>=layoutConfig.maxNumRows){currentRow=null;return true}currentRow=createNewRow()}}}});if(currentRow&&currentRow.getItems().length&&layoutConfig.showWidows){if(layoutData._rows.length){if(layoutData._rows[layoutData._rows.length-1].isBreakoutRow){nextToLastRowHeight=layoutData._rows[layoutData._rows.length-1].targetRowHeight}else{nextToLastRowHeight=layoutData._rows[layoutData._rows.length-1].height}currentRow.forceComplete(false,nextToLastRowHeight)}else{currentRow.forceComplete(false)}laidOutItems=laidOutItems.concat(addRow(currentRow));layoutConfig._widowCount=currentRow.getItems().length}layoutData._containerHeight=layoutData._containerHeight-layoutConfig.boxSpacing.vertical;layoutData._containerHeight=layoutData._containerHeight+layoutConfig.containerPadding.bottom;return{containerHeight:layoutData._containerHeight,widowCount:layoutConfig._widowCount,boxes:layoutData._layoutItems}}module.exports=function(input,config){var defaults={containerWidth:1060,containerPadding:10,boxSpacing:10,targetRowHeight:320,targetRowHeightTolerance:.25,maxNumRows:Number.POSITIVE_INFINITY,forceAspectRatio:false,showWidows:true,fullWidthBreakoutRowCadence:false,widowLayoutStyle:"left"};var containerPadding={};var boxSpacing={};config=config||{};layoutConfig=merge(defaults,config);containerPadding.top=!isNaN(parseFloat(layoutConfig.containerPadding.top))?layoutConfig.containerPadding.top:layoutConfig.containerPadding;containerPadding.right=!isNaN(parseFloat(layoutConfig.containerPadding.right))?layoutConfig.containerPadding.right:layoutConfig.containerPadding;containerPadding.bottom=!isNaN(parseFloat(layoutConfig.containerPadding.bottom))?layoutConfig.containerPadding.bottom:layoutConfig.containerPadding;containerPadding.left=!isNaN(parseFloat(layoutConfig.containerPadding.left))?layoutConfig.containerPadding.left:layoutConfig.containerPadding;boxSpacing.horizontal=!isNaN(parseFloat(layoutConfig.boxSpacing.horizontal))?layoutConfig.boxSpacing.horizontal:layoutConfig.boxSpacing;boxSpacing.vertical=!isNaN(parseFloat(layoutConfig.boxSpacing.vertical))?layoutConfig.boxSpacing.vertical:layoutConfig.boxSpacing;layoutConfig.containerPadding=containerPadding;layoutConfig.boxSpacing=boxSpacing;layoutData._layoutItems=[];layoutData._awakeItems=[];layoutData._inViewportItems=[];layoutData._leadingOrphans=[];layoutData._trailingOrphans=[];layoutData._containerHeight=layoutConfig.containerPadding.top;layoutData._rows=[];layoutData._orphans=[];layoutConfig._widowCount=0;return computeLayout(input.map(function(item){if(item.width&&item.height){return{aspectRatio:item.width/item.height}}else{return{aspectRatio:item}}}))}},{"./row":1,merge:2}]},{},[]);

// ------ Tessaray Initialization ------
var Tessarray = function(containerSelector, boxSelector, options) {
  this.container = document.querySelector(containerSelector);
  this._eventListeners = {};
  this._hasRendered = false;

  this._setOptions(options);

  this._setFiltersAndSorters();

  this._styleContainer();

  this._defineTransitions();

  // Should this go in set Transitions
  if (this.options.containerTransition) {
    this.container.style.transition = this._containerTransition;
  }

  this._setContainerPadding();

  this._setEventListeners();

  this._bindAndPrepareFilteringAndSorting();

  // Create boxNodes and boxObjects for Tessarray instance
  this._createBoxes(boxSelector);

  // Set values to numbers if possible
  this._changeSortValuesToNumbersIfPossible();

  // Confirm that this.container has the correct data and is ready to render
  this._setContainerState();
};

Tessarray.prototype._setOptions = function(options) {
  this.options = options || {};
  
  // Set default values for options
  this._setOptionValue("selectorClass", false);
  this._setOptionValue("selectorEventListener", "click");
  this._setOptionValue("initialRender", {
    filter: "",
    sort: "",
    order: ""
  });
  this._setOptionValue("filters", []);
  this._setOptionValue("sorters", []);
  this._setOptionValue("resize", true);
  this._setOptionValue("containerTransition", {
    duration: 300,
    timingFunction: "ease-in",
    delay: 0
  });
  this._setOptionValue("boxTransition", {
    duration: 500,
    timingFunction: "ease-in",
    delay: 0
  });
  this._setOptionValue("boxTransformOutTransition", {
    duration: 250,
    timingFunction: "ease-in",
    delay: 0
  });
  this._setOptionValue("containerLoadedClass", 'container-is-loaded');
  this._setOptionValue("boxLoadedClass", 'is-loaded');
  this._setOptionValue("onContainerLoad", false);
  this._setOptionValue("onBoxLoad", false);
  this._setOptionValue("onRender", false);
  this._setOptionValue("flickr", {});
};

Tessarray.prototype._setOptionValue = function(key, defaultValue) {
  if (this.options[key] === undefined) {
    this.options[key] = defaultValue;
  }
};

Tessarray.prototype._setFiltersAndSorters = function() {
  this.filters = this.options.filters;
  this.sortData = {};
  this.options.sorters.forEach(function(option) {
    this.sortData[option] = {numeric: true};
  }.bind(this));
}

Tessarray.prototype._styleContainer = function() {
  this.container.style.position = "relative";

  // This will be changed to 1 once the first layout geometry is loaded
  this.container.style.opacity = "0"; 
  
  // This is needed to reflow before adding transition
  this.container.offsetTop;

  // Determine if user specifies containerWidth using flickr in initialization
  this._specifiedContainerWidth = !!this.options.flickr.containerWidth;

  // Set width that is passed to the Justified Layout to be the current width of the container
  this._setContainerWidth();
};

Tessarray.prototype._setContainerWidth = function() {
  if (!this._specifiedContainerWidth) {
    this.options.flickr.containerWidth = this.container.clientWidth;
  }
};

Tessarray.prototype._defineTransitions = function() {
  // containerTransition controls the container's transition from 0 opacity to 1 once the container is loaded.
  if (typeof this.options.containerTransition === "object") {
    this._containerTransition = "opacity " + this.options.containerTransition.duration + "ms " + this.options.containerTransition.timingFunction + " " + this.options.containerTransition.delay + "ms";
  } else if (typeof this.options.containerTransition === "string") {
    this._containerTransition = this.options.containerTransition;
  } else {
    this._containerTransition = false;
  }

  // boxTransition controls the movement of boxes, the resizing of boxes, and the scaling of boxes from 0 to 1.
  if (typeof this.options.boxTransition === "object") {
    this._boxTransition = "transform " + this.options.boxTransition.duration + "ms " + this.options.boxTransition.timingFunction + " " + this.options.boxTransition.delay + "ms, height " + this.options.boxTransition.duration + "ms " + this.options.boxTransition.timingFunction + " " + this.options.boxTransition.delay + "ms, width " + this.options.boxTransition.duration + "ms " + this.options.boxTransition.timingFunction + " " + this.options.boxTransition.delay + "ms";
  } else if (typeof this.options.boxTransition === "string") {
    this._boxTransition = this.options.boxTransition;
  } else {
    this._boxTransition = false;
  }

  // boxTransformOutTransition controls the scaling of boxes from 1 to 0. 
  if (typeof this.options.boxTransformOutTransition === "object") {
    this._boxTransformOutTransition = "transform " + this.options.boxTransformOutTransition.duration + "ms " + this.options.boxTransformOutTransition.timingFunction + " " + this.options.boxTransformOutTransition.delay + "ms";
  } else if (typeof this.options.boxTransformOutTransition === "string") {
    this._boxTransformOutTransition = this.options.boxTransformOutTransition;
  } else {
    this._boxTransformOutTransition = false;
  }
}

Tessarray.prototype._setContainerPadding = function() {
  // If user specified containerPadding, use it to calculate height
  if (this.options.flickr.containerPadding) {

    // If user passed a number, use the number
    if (typeof this.options.flickr.containerPadding === "number") {
      this._containerPaddingBottom = this.options.flickr.containerPadding;

    // Else if user passed an object and bottom is truthy, use that value
    } else if (this.options.flickr.containerPadding.bottom) {
      this._containerPaddingBottom = this.options.flickr.containerPadding.bottom;

    // If user passed an object and bottom is not truthy, use 0
    // This prevents breaking if user does not put bottom in the object
    } else {
      this._containerPaddingBottom = 0;
    }

  // Else use the Flickr default _containerPaddingBottom for height calculation
  } else {
    this._containerPaddingBottom = 10;
  }
}

Tessarray.prototype._setEventListeners = function() {

  // The _eventListeners object is used to store functions have been added to which
  // elements so they can be removed in the destroy method.
  this._eventListeners.container = function(event) {
    if (event.target === this.container) {
      this._addTransitionToAllBoxNodes();
      this.container.removeEventListener('transitionend', this._eventListeners.container); 
    }
  }.bind(this);

  // If transition is set and its duration is greater than 0
  if ((this.options.containerTransition !== false) && (typeof this.options.containerTransition !== "object" || this.options.containerTransition.duration !== 0)) {
    try {
      this.container.addEventListener('transitionend', this._eventListeners.container);
    } catch (e) {
      console.error('Cannot find container with selectorString "' + containerSelector + '"');
    }
  }

  // If this.options.resize, resize the container upon window size change if 
  // container size is modified
  if (this.options.resize) {
    this._eventListeners.window = this._renderOnResize.bind(this);
    window.addEventListener("resize", this._eventListeners.window);
  }
}

Tessarray.prototype._bindAndPrepareFilteringAndSorting = function() {
  if (this.options.selectorClass) {
    this._selectors = document.getElementsByClassName(this.options.selectorClass);
    for (var i = 0; i < this._selectors.length; i++) {
      var filterString = this._selectors[i].getAttribute("data-filter");
      var sortString = this._selectors[i].getAttribute("data-sort");
      var sortOrder = this._selectors[i].getAttribute("data-sort-order");

      // Add event listeners for filtering and sorting if filterString and sortString exist
      if ((filterString !== null) && (sortString !== null)) {
        this._eventListeners[i] = this.filterAndSort.bind(this, filterString, sortString, sortOrder);
      } else if (filterString !== null) {
        this._eventListeners[i] = this.filter.bind(this, filterString);
      } else if (sortString !== null) {
        this._eventListeners[i] = this.sort.bind(this, sortString, sortOrder);
      }

      // If there was a valid filterString or valid sortString, bind _eventListeners[i] to click
      if (this._eventListeners[i]) {
        this._selectors[i].addEventListener(this.options.selectorEventListener, this._eventListeners[i]);
      }

      // Add filter and sort to Tessarray's collections
      if (filterString) {
        this.filters.push(filterString);
      }
      if (sortString) {
        this.sortData[sortString] = {numeric: true};
      }
    }
  }
}

Tessarray.prototype._changeSortValuesToNumbersIfPossible = function() {
  if (this.options.selectorClass) {
    for (var sortKey in this.sortData) {
      if (this.sortData[sortKey].numeric) {
        this._changeSortValuesToNumbers(sortKey);
      }
    }
  }
}

Tessarray.prototype._changeSortValuesToNumbers = function(sortKey) {
  if (sortKey !== "") {
    this.boxObjects.forEach(function(boxObject) {
      if (boxObject.sortData[sortKey] !== false) {
        boxObject.sortData[sortKey] = +boxObject.sortData[sortKey].replace(/,/g, "");
      }
    });
  }
}

Tessarray.prototype._setContainerState = function() {
  this._containerIsReady = true;
  if (this._boxesAreReady()) {
    this._initialRender();
  }
};

// Determine if every element that needs to load has loaded its dimensions
Tessarray.prototype._boxesAreReady = function() {
  if (!this._boxesHaveBeenCreated) {
    return false; 
  } else {
    for (var i = 0; i < this._boxesAspectRatioStates.length; i++) {
      if (!this._boxesAspectRatioStates[i]) {
        return false;
      }
    }
  }
  return true;
};


// ------ TessarrayBox Initialization ------
Tessarray.prototype._createBoxes = function(boxSelector) {
  // Scope boxes to containerSelector
  var boxes = this.container.querySelectorAll(boxSelector);
  // Array of html nodes of each box
  this.boxNodes = [];
  // Array of javascript objects representing each box
  this.boxObjects = [];
  // Instantiate variables to keep track of whether or not Tessarray needs to wait to load the image dimensions before rendering
  this._boxesAspectRatioStates = [];

  // For each box node create a newBoxObject
  var invalidBoxNodeCount = 0;
  for (var i = 0; i < boxes.length; i++) {
    var newBoxObject = new TessarrayBox(boxes[i], i, this);

    // Add this newBoxObject to this.boxObjects and the node to this.boxNodes if there is a valid image
    if (!newBoxObject.invalid) {
      this.boxObjects[i - invalidBoxNodeCount] = newBoxObject;
      this.boxNodes[i - invalidBoxNodeCount] = boxes[i];
      this.boxNodes[i - invalidBoxNodeCount].style.position = "absolute";

    // Else incremement counter to ensure there are not gaps in this.boxObjects or this.boxNodes arrays
    } else {
      invalidBoxNodeCount += 1;
    }
  }

  this._boxesHaveBeenCreated = true;
}

var TessarrayBox = function(box, index, tessarray) {
  this.index = index;
  this.boxNode = box;
  this.tessarray = tessarray;
  this.filters = [];
  this.sortData = {};

  // Indicate to the tessarray object that the current image has not yet loaded
  this.tessarray._boxesAspectRatioStates[this.index] = false; 

  this._setFilters();
  this._setSortData();

  this._loadImagesAndSetAspectRatios();
};

TessarrayBox.prototype._setFilters = function() {
  this.tessarray.filters.forEach(function(filter) {
    if (this.boxNode.classList.contains(filter)) {
      this.filters.push(filter);
    }
  }.bind(this));
}

TessarrayBox.prototype._setSortData = function() {
  for (var key in this.tessarray.sortData) {
    var sortValue = this._setSortValue(key)

    // If sortValue is falsey, explicitly set to false
    if (!sortValue) {
      sortValue = false;

    // Check if it is still possibly a numeric field
    } else if (this.tessarray.sortData[key].numeric) {
      // If sortValue cannot be turned into a number, set value to false
      if (!this._isValidNumber(sortValue)) {
        this.tessarray.sortData[key].numeric = false;
      }
    }
    
    this.sortData[key] = sortValue;
  }
}

TessarrayBox.prototype._setSortValue = function(key) {
  // If key is prepended with "data-", search the box's data attributes for the value
  if (key.slice(0, 5) === "data-") {
    sortValue = this.boxNode.dataset[this._camelCase(key.slice(5))];
  } else {

    // Else search for an element with the correct class and get its innerHTML 
    if (this.boxNode.getElementsByClassName(key)[0]) {
      sortValue = this.boxNode.getElementsByClassName(key)[0].innerHTML.toLowerCase().trim();
    } else {
      sortValue = false;
    }
  }
  return sortValue;
}

TessarrayBox.prototype._camelCase = function(string) {
  return string.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}

TessarrayBox.prototype._isValidNumber = function(string) {
  return !(+string.replace(/,/g, "") !== +string.replace(/,/g, ""));
}

TessarrayBox.prototype._loadImagesAndSetAspectRatios = function() {
  // Find the image to be rendered in the boxNode. Use the node itsel if the boxNode is an image
  if (this.boxNode.querySelector('img')) {
    this.image = this.boxNode.querySelector('img');
  } else if (this.boxNode.tagName === "IMG") {
    this.image = this.boxNode;
  }

  // If data attribute for aspect ratio is set or data attribute for height and width are set, call setAspectRatio.
  if (this.boxNode.getAttribute('data-aspect-ratio') || (this.boxNode.getAttribute('data-height') && this.boxNode.getAttribute('data-width'))) {
    this._setAspectRatio(this.tessarray, this.index);

  // If the image doesn't exist and it does not have height and width or aspect ratio, 
  // call confirm load so the initial render does not wait on this image and raise an error.
  } else if (!this.image || !this.image.getAttribute('src')) {
    this.invalid = true; 
    this.tessarray._boxIsReady(this.index);
    console.error("One of your images does not exist.");

  // Else, get aspect ratio by loading the image source into Javascript, then _boxIsReady once
  // the image has loaded.
  } else {
    var source = this.image.getAttribute('src');
    var img = new Image();
    var thisBoxObj = this;
    img.onload = function() {
      thisBoxObj.aspectRatio = this.width / this.height;
      thisBoxObj.tessarray._boxIsReady(thisBoxObj.index);
      thisBoxObj.boxNode.classList.add(thisBoxObj.tessarray.options.boxLoadedClass);
      if (typeof thisBoxObj.tessarray.options.onBoxLoad === "function") {
        thisBoxObj.tessarray.options.onBoxLoad(thisBoxObj);
      }
    };
    img.src = source;
  }
}
 
// Set aspect ratio for TessarrayBox and then _boxIsReady.
// If TessarrayBox has an image, this loads image in javascript before setting 
// the boxLoadedClass and triggering the onBoxLoad
TessarrayBox.prototype._setAspectRatio = function(tessarray, index) {
  if (this.boxNode.getAttribute('data-aspect-ratio')) {
    this.aspectRatio = parseFloat(this.boxNode.getAttribute('data-aspect-ratio'));
  } else if (this.boxNode.getAttribute('data-height') && this.boxNode.getAttribute('data-width')) {
    this.aspectRatio = parseFloat(this.boxNode.getAttribute('data-width')) / parseFloat(this.boxNode.getAttribute('data-height'));
  } 
  tessarray._boxIsReady(index);

  // If image exists, load it
  if (this.image) {
    var source = this.image.getAttribute('src');
    var img = new Image();
    var thisBoxObj = this;
    img.onload = function() {
      thisBoxObj.boxNode.classList.add(tessarray.options.boxLoadedClass);
      if (typeof tessarray.options.onBoxLoad === "function") {
        tessarray.options.onBoxLoad(thisBoxObj);
      }
    };
    img.src = source;

  // Else trigger boxLoaded immediately.
  } else {
    this.boxNode.classList.add(tessarray.options.boxLoadedClass);
    if (typeof tessarray.options.onBoxLoad === "function") {
      tessarray.options.onBoxLoad(this);
    }
  }
};

// Set index of _boxesAspectRatioStates to be true. If every element in _boxesAspectRatioStates is either
// true or undefined, then the intial render is called. 
Tessarray.prototype._boxIsReady = function(index) {
  this._boxesAspectRatioStates[index] = true;
  if (this._boxesAreReady() && this._containerIsReady) {
    this._initialRender();
  }
};

// ------ Filtering And Sorting Methods ------

Tessarray.prototype.filterAndSort = function(filterString, sortString, order) {
  // If not the first render and there have been no changes to filtering, sorting, or order, break out of filterAndSort
  if ((this._hasRendered) && ((filterString === this.activeFilter) || (filterString === false)) && ((sortString === this.activeSort) || (sortString === false)) && ((order === this.activeOrder) || (order === false))) {
    // Do nothing
  } else {
    this._filter(filterString);
    this._sort(sortString, order);
    this.render();
  }
}

Tessarray.prototype.filter = function(filterString) {
  this._filter(filterString);
  this._sort(this.activeSort, false);
  this.render();
}

Tessarray.prototype.sort = function(sortString, order) {
  this._sort(sortString, order);
  this.render();
}

Tessarray.prototype._filter = function(filterString) {
  if ((this._hasRendered) && ((filterString === this.activeFilter) || (filterString === false))) {
    return;
  }
  // Filter
  if ((filterString === this.activeFilter) || (filterString === false)) {
    // Do nothing
  } else if (filterString === "") {
    this.activeFilter = filterString;
    this.filteredAndSortedBoxes = this.boxObjects.slice();
  } else {
    this.activeFilter = filterString;
    this.filteredAndSortedBoxes = this.boxObjects.filter(function(box) {
      return box.filters.indexOf(filterString) >= 0;
    });
  }
}

Tessarray.prototype._sort = function(sortString, order) {

  // Allow users to pass false to not reOrder. Otherwise order will be overwritten each time.
  if (order === false) {
    order = this.activeOrder;
  }

  var orderMath;
  if (order === "desc" || order === "descending") {
    orderMath = -1;
  } else {
    orderMath = 1;
  }

  // Else if sortString or order differ from the current sort, set activeSort
  // Always set activeOrder so default ascending order is maintained if a sort is passed
  if (sortString !== false) {
    this.activeSort = sortString;
  }
  this.activeOrder = order;

  if (this.activeSort === "") {
    this.filteredAndSortedBoxes = this.filteredAndSortedBoxes.sort(function(boxA, boxB) {
      return (boxA.index - boxB.index) * orderMath;
    });
  } else {

    // Place boxes without values (thus given value of false) at the end
    // Reverse what is returned if order is descending
    this.filteredAndSortedBoxes = this.filteredAndSortedBoxes.sort(function(boxA, boxB) {
      if (boxA.sortData[sortString] === false) {
        return 1;
      } else if (boxB.sortData[sortString] === false) {
        return -1;
      } else if (boxA.sortData[sortString] < boxB.sortData[sortString]) {
        return -1 * orderMath;
      } else if (boxA.sortData[sortString] > boxB.sortData[sortString]) {
        return 1 * orderMath;
      } else {
        return 0;
      }
    });
  }
}

// ------ Render Methods ------

// Rerender the boxes if the container width has not been specified and container width has changed since last render
Tessarray.prototype._renderOnResize = function() {
  if ((!this._specifiedContainerWidth) && (this.options.flickr.containerWidth !== this.container.clientWidth)) {
    this.debounce(this.render.bind(this), 100)();
  }
};

// Debounce used to prevent tessarray from calling render too frequently when resizing window.
Tessarray.prototype.debounce = function(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};

// Render the boxes for the first time
Tessarray.prototype._initialRender = function() {
  // Make the container opaque, add containerLoaded class, and trigger onContainerLoad.
  this.container.style.opacity = "1";
  this.container.classList.add(this.options.containerLoadedClass);
  if (typeof this.options.onContainerLoad === "function") {
    this.options.onContainerLoad(this);
  }

  // If selectors are being used and there is a defaultFilter defaultSort, sort and filter on those values
  // before initial render.
  if (this.options.selectorClass && (this.options.initialRender.filter || this.options.initialRender.sort || this.options.initialRender.order)) {
    this.filterAndSort(this.options.initialRender.filter, this.options.initialRender.sort, this.options.initialRender.order);

  // Else, render every box
  } else {
    this.filteredAndSortedBoxes = this.boxObjects.slice();
    this.render();
  }
};

// Render the boxes with the correct coordinates
Tessarray.prototype.render = function() {
  this._setContainerWidth();
  // Get coordinates from Flickr Justified Layout using an array of the aspect ratios of the filteredAndSortedBoxes. 
  this.layoutGeometry = require('justified-layout')(this.filteredAndSortedBoxes.map(function(box) { return box.aspectRatio; }), this.options.flickr);

  // Give container appropriate height for the images it contains.
  if (this.layoutGeometry.boxes.length > 0) {
    var height = this.layoutGeometry.boxes[this.layoutGeometry.boxes.length - 1].top + this.layoutGeometry.boxes[this.layoutGeometry.boxes.length - 1].height + this._containerPaddingBottom;
    this.container.style.height = height.toString() + "px";
  } else {
    this.container.style.height = "0px";
  }

  // If not the initial render, ensure that there are transitions for height, width and translate
  // for each box
  if (this._hasRendered) {
    this._addTransitionToAllBoxNodes();
  } 

  // For each boxNode
  for (var i = 0; i < this.boxObjects.length; i++) {

    // If this box is to be rendered in the current filteration
    var boxObjectIndex = this.filteredAndSortedBoxes.indexOf(this.boxObjects[i]);
    if (boxObjectIndex >= 0) {

      // Grab the appropriate box information from Flickr Justified layout
      var box = this.layoutGeometry.boxes[boxObjectIndex];

      // Apply Flickr data to the selected box unless box is undefined. Box can be undefined if it was not
      // filtered out, but is not rendered due to Flickr options (such as showWidows: false).
      if (box !== undefined) {
        this.boxNodes[i].style.transform = "translate(" + box.left + "px, " + box.top + "px) scale(1)";
        this.boxNodes[i].style.height = box.height + "px";
        this.boxNodes[i].style.width = box.width + "px";

      // If it is undefined, scale it down to 0
      } else {
        this._scale(this.boxNodes[i], 0);
      }

    // Else remove the boxNode from sight
    } else {
      this._scale(this.boxNodes[i], 0);
    }
  }

  if (typeof this.options.onRender === "function") {
    this.options.onRender(this, !this._hasRendered);
  }

  // Is this necessary for a reflow?
  this.container.offsetTop;

  this._hasRendered = true;
};

// Helper method to change the scale of boxNodes without overwriting their translated position
Tessarray.prototype._scale = function(boxNode, scale) {
  if (this._boxTransformOutTransition) {
    boxNode.style.transition = this._boxTransformOutTransition;
  }

  var transformStyle = boxNode.style.transform;
  // If boxNode has a transform style already, change the scale but not the translation
  if (transformStyle !== "") {
    boxNode.style.transform = transformStyle.replace(/(scale\()(\d)(\))/, ("$1" + scale.toString() + "$3"));
  } else {
    boxNode.style.transform = "translate(0px, 0px) scale(" + scale.toString() + ")";
  }
};

// Add transition to boxes. This is called every render except for the initial render
Tessarray.prototype._addTransitionToAllBoxNodes = function() {
  if (this._boxTransition) {
    for (var i = 0; i < this.boxNodes.length; i++) {
      this.boxNodes[i].style.transition = this._boxTransition;
    }
  }
};

// ------ Destroy ------
// Remove event listeners on selectors and window, remove transition from container and boxNodes.
// Remove pointers to boxObjects. Leaving position and such so the display does not change.
Tessarray.prototype.destroy = function() {
  if (this._eventListeners.window) {
    window.removeEventListener('resize', this._eventListeners.window);
  }
  if (this._eventListeners.container) {
    this.container.removeEventListener('transitionend', this._eventListeners.container);
  }

  if (this.options.containerTransition) {
    this.container.style.transition = "";
  }

  this.container.classList.remove(this.options.containerLoadedClass);

  for (var i = 0; i < this.boxNodes.length; i++) {
    this.boxNodes[i].style.transition = "";
    this.boxNodes[i].classList.remove(this.options.boxLoadedClass);
  }

  if (this._selectors) {
    for (var j = 0; j < this._selectors.length; j++) {
      this._selectors[j].removeEventListener(this.options.selectorEventListener, this._eventListeners[j]);
    }
  }

  delete this.boxObjects;
};